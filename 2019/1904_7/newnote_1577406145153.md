一、登录
    JWT登录
二、表设计
    1、订单表
        订单id (雪花算法)  用户id(会员id)  订单支付方式 (微信，支付宝)
        （订单的总金额 订单中商品的总件数）--库存是否充足
        订单的创建时间 --超时自动关闭交易并在状态添加超时描述
        订单的支付时间 订单交易关闭的时间 订单发货时间 订单交易成功的时间 订单完成评价的时间
        订单的状态 【未支付10  已支付20   已发货30   交易成功40  交易关闭50  已完成评价60】订单状态描述
               交易成功 --确认收货，未确认收货15天自动交易成功
	交易关闭 --手动取消，超时自动，退款
        收件人名字 收件人手机号 收件人地址 邮编 邮费 是否需要发票
	--冗余字段，避免多表联查获取这些信息，因为多表联查会降低性能。

     2、订单明细表
	订单id: 商品id: 用户id: 商品名: 商品价格: 商品个数：商品小计: 商品图片:
 	   联合主键     冗余字段       多个字段来保证一条数据唯一性
三、接口 
（重复下单的问题，超卖，把redis中存储的购物车数据取出来，插入订单明细表，订单表以及支付日志表。）
    1、重复下单
        1.1、幂等性
	--出现的问题
	--redis+token的方式解决
	创建token的接口，uuid作为token，存储到redis，10分钟过期，客户端调用接口生成唯一的token标识，在后续请求将token作为header中的信息传入到接口服务端验证。

	--自定义幂等性注解，幂等性拦截器
	判断是最核心。
	  是否包含token头信息
	    --否。提示头信息丢失
	    --是。则获取该token的内容
	       --调用redis中的exist判断在redis中是否有该token--不存在则提示token为空
	   最后就是调用redis的delete方法
	    --将该token作为key进行删除操作
	       --返回值等于0 ，已经有其他请求发送提示请求重复
	       --否则证明是第一个请求，放行
		
    2、订单超卖
        2.1、redis中取出用户的购物车数据
	--购物车为空or不为空
	  --不为空取出用户对应的购物车的json数据，将其转换为java对象
	--插入订单明细表
	  --雪花算法生成订单id，java对象中取出商品列表对应订单明细，循环遍历。
	  --减库存  成功就插入。不成功不插入
	  --将更新后的购物车信息中的总价格和商品总件数插入到订单表中，并设置创建时间为当前时间，当前订单状态为未支付。将库存不足的商品加入列表，用于响应前端提示。
	--支付日志表
	   插入的订单id，状态设置为未支付，插入到redis支付的时候进行使用，用hdel进行清空redis中的购物车数据，如购物车中的商品都库存不足，下单失败，不需要插入订单表和支付日志表
	--数据库乐观锁
	update 商品表 set 库存=库存-购买量 where 商品id=购物中的商品id
	and 库存量>=购买量